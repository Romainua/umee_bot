package main

import (
	"encoding/json"
	"fmt"

	//	"io/ioutil"
	"log"
	//	"os"
	"os/exec"
	"regexp"
	"strconv"
	"strings"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

type AutoGenerated struct { //output for validatros status on stuct
	Validators []struct {
		//			OperatorAddress string `json:"operator_address"`
		Status      string `json:"status"`
		Description struct {
			Moniker string `json:"moniker"`
		} `json:"description"`
	} `json:"validators"`
}


func main() {
	bot, err := tgbotapi.NewBotAPI("TOKEN_BOT")
	if err != nil {
		log.Panic(err)
	}

	log.Printf("Authorized on account %s", bot.Self.UserName)

	u := tgbotapi.NewUpdate(0)
	u.Timeout = 60

	updates := bot.GetUpdatesChan(u)

	for update := range updates {
		if update.Message != nil { // If we got a message
			msgArr := strings.Split(update.Message.Text, " ")
			log.Printf("[%s] %s ", update.Message.Chat.UserName, update.Message.Text)
			switch msgArr[0] {
			case "/balance":				

				bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Input your address"))
				for update := range updates {
					if update.Message != nil {
						address := update.Message.Text
						log.Printf("[%s] %s", update.Message.From.UserName, update.Message.Text) //got log message in cli

						var (
							out []byte
							err error
						)
						type AutoGenerated struct {
							Balances []struct {
								Amount string `json:"amount"`
							} `json:"balances"`
						}

						out, err = exec.Command("starsd", "q", "bank", "balances", address, "--node", "https://stargaze.c29r3.xyz:443/rpc", "--output", "json").Output()
						if err != nil {
							bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Input correct address"))
							continue
						}

						lookFor := "ustars"
						contain := strings.Contains(string(out), lookFor) //find key word(ustar) in output from out (starsd)
						if contain == true {                              //if it successful
							data := AutoGenerated{}
							jsonErr := json.Unmarshal(out, &data)
							if jsonErr != nil {
								log.Fatal(jsonErr)
							}

							amount, _ := strconv.ParseFloat(data.Balances[0].Amount, 64) //convert to float
							amountMath := amount / 1000000
							str := fmt.Sprintf("%.2f", amountMath)
							bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Balance is "+str+" stars"))
							break

						} else if contain == false { //if it didn't successful
							bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Balance is 0 stars"))
							break
						}

					}
				}
			case "/status":

				var (
					out []byte
					err error
				)

				out, err = exec.Command("starsd", "q", "staking", "validators", "--node", "https://stargaze.c29r3.xyz:443/rpc", "--output", "json").Output()

				if err != nil {
					log.Fatal(err)
				}
				data := AutoGenerated{}
				jsonErr := json.Unmarshal(out, &data)
				if jsonErr != nil {
					log.Fatal(jsonErr)
				}

				var status = data.Validators[0].Status
				var exit = strings.Contains(status, "BOND_STATUS_BONDED")
				if exit == true {

					bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, data.Validators[0].Description.Moniker+" is Active!"))
				} else {
					bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, data.Validators[0].Description.Moniker+" is  Inactive"))
				}

				for _, s := range data.Validators {
					str := fmt.Sprintf("%s", s)

					var re = regexp.MustCompile(`{BOND_STATUS_BONDED {`)
					var re1 = regexp.MustCompile(`{BOND_STATUS_UNBONDING {`)
					var re2 = regexp.MustCompile(`{BOND_STATUS_UNBONDED {`)
					var re3 = regexp.MustCompile(`}}`)

					strRe := re.ReplaceAllString(str, "Status: Active ✅ Moniker: ")
					strRe1 := re1.ReplaceAllString(strRe, "Status: Jailed ⚠️ Moniker: ")
					strRe2 := re2.ReplaceAllString(strRe1, "Status: Inactive ❌ Moniker: ")
					strRe3 := re3.ReplaceAllString(strRe2, "")
					bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, strRe3))
				}
			default:
				bot.Send(tgbotapi.NewMessage(update.Message.Chat.ID, "Sorry, now i know only '/balance' and '/status' commands"))
			}

		}
	}
}

func (a AutoGenerated) String() string {
	return fmt.Sprintf("%q", a.Validators)
}

func query() string {
	var (
		out []byte
		err error
	)
	type AutoGenerated struct {
		Balances []struct {
			Denom  string `json:"denom"`
			Amount string `json:"amount"`
		} `json:"balances"`
	}

	out, err = exec.Command("starsd", "q", "bank", "balances", "stars13htkxk8nw6qwhfdugllp8ldtgt5nm80xzy23vv", "--node", "https://stargaze.c29r3.xyz:443/rpc", "--output", "json").Output()

	if err != nil {
		log.Fatal(err)
	}
	data := AutoGenerated{}
	jsonErr := json.Unmarshal(out, &data)
	if jsonErr != nil {
		log.Fatal(jsonErr)
	}

	amount, _ := strconv.ParseFloat(data.Balances[0].Amount, 64)
	amountMath := amount / 1000000
	amountString := strconv.Itoa(int(amountMath))
	return (amountString)
}

func queryVal() string {
	var (
		out []byte
		err error
	)
	type AutoGenerated struct {
		Validators []struct {
			//			OperatorAddress string `json:"operator_address"`
			Status      string `json:"status"`
			Description struct {
				Moniker string `json:"moniker"`
				Website string `json:"website"`
				Details string `json:"details"`
			} `json:"description"`
			Commission struct {
				CommissionRates struct {
					Rate string `json:"rate"`
				} `json:"commission_rates"`
			} `json:"commission"`
		} `json:"validators"`
	}
	out, err = exec.Command("starsd", "q", "staking", "validators", "--node", "https://stargaze.c29r3.xyz:443/rpc", "--output", "json").Output()

	if err != nil {
		log.Fatal(err)
	}
	data := AutoGenerated{}
	jsonErr := json.Unmarshal(out, &data)
	if jsonErr != nil {
		log.Fatal(jsonErr)
	}
	//status := data.Validators[0].Status

	output := string(out)

	return string(output)
}

